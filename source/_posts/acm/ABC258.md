---
title: AtCoder Beginner Contest 258 E(循环节) G
tags: 题解
categories: Atcoder
abbrlink: dd2281be
date: 2022-07-03 14:44:10
updated: 2022-07-03 14:44:10
---

<!-- more -->

---

# E Packing Potatoes  (循环节)
## 题意
有无限个土豆，每个土豆重量由序列W决定，第$i$个土豆重量为$W_{i-1}\mod N$。将这些土豆转入盒子中，当盒子中土豆重量超过$X$则将土豆密封，换新的盒子

问第$K$个盒子中有几个土豆。

## 分析

由于$K$的数据范围很大，可以发现又是个找循环节的题(~~ABC貌似挺喜欢出这种题的?~~)

可以发现，每装完一个盒子后，又会从新的盒子开始装，设第$j$个盒子从第$i$个土豆开始装，装了$P[i]$个土豆，那么第$j+1$个盒子将会从第$i+P[i]$个土豆开始装。
例如样例

> 3 2 5
> 3 4 1

第$1$个盒子从第$0$个土豆开始装，装了$2$个，则第$2$个盒子便从第$0+2=2$个土豆开始装。

因为$N\le 2\times 10^5$ ,考虑最坏情况，前$N$个盒子都从第不同个土豆开始装，第$N+1$个盒子必然会以前面出现过的土豆开始装，所以循环节长度有限，我们可以找到循环节。

我们可以通过二分或双指针找到以每一个土豆开始装满一盒，能装多少个。

``` cpp
for(int i=0;i<n;++i){
    ll X = x;
    p[i]=X/pre[n]*n;
    X%=pre[n];
    int l = 0,r = n;
    while(l<r){
        int mid = l+r>>1;
        int j = i+mid-1;
        ll t;
        if(j<n)t = get_sum(i,j);
        else t = get_sum(i,n-1)+get_sum(0,j%n);
        if(t>=X)r = mid;
        else l = mid+1;
    }
    p[i]+=l;
}
```

然后就是找循环节了，虽然写过很多次类似的题，但找循环节这块还是写的特别丑

``` cpp
vector<ll>ans;
vector<ll>vis(n,-1);
ll i = 0,l=-1;
while(1){
    ans.push_back(p[i]);
    if(vis[i]==-1)vis[i]=ans.size()-1;
    ll j = (i+p[i])%n;
    if(~vis[j]){
        l=vis[j];
        break;
    }
    i = j;
}
```

## 完整代码

``` cpp
#include<bits/stdc++.h>
#define all(x) begin(x), end(x)
using namespace std;
using ll = long long;
using PII = pair<int,int>;
constexpr int mod = 998244353;
constexpr int INF = 0x3f3f3f3f;
constexpr int N = 1e5+5;
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n,q,x;
    cin>>n>>q>>x;
    vector<ll>w(n),pre(n+1),p(n);
    for(auto&x:w)cin>>x;
    for(int i=0;i<n;++i)pre[i+1]=pre[i]+w[i];
    auto get_sum = [&](int l,int r)->ll{
        if(l>r+1)return 0ll;
        return pre[r+1]-pre[l];
    };
    for(int i=0;i<n;++i){
        ll X = x;
        p[i]=X/pre[n]*n;
        X%=pre[n];
        int l = 0,r = n;
        while(l<r){
            int mid = l+r>>1;
            int j = i+mid-1;
            ll t;
            if(j<n)t = get_sum(i,j);
            else t = get_sum(i,n-1)+get_sum(0,j%n);
            if(t>=X)r = mid;
            else l = mid+1;
        }
        p[i]+=l;
    }
    // for(int i=0;i<n;++i){
    //     cout<<i<<' '<<p[i]<<'\n';
    // }
    vector<ll>ans;
    vector<ll>vis(n,-1);
    ll i = 0,l=-1;
    while(1){
        ans.push_back(p[i]);
        if(vis[i]==-1)vis[i]=ans.size()-1;
        ll j = (i+p[i])%n;
        if(~vis[j]){
            l=vis[j];
            break;
        }
        i = j;
    }
    int m = ans.size()-l;
    while(q--){
        ll k;
        cin>>k;
        --k;
        if(k<l)cout<<ans[k]<<'\n';
        else {
            k = (k-l)%m+l;
            cout<<ans[k]<<'\n';
        }
    }
    return 0;
}
```

# G Triangle (bitset)

## 题意

给一个$N \times N$的邻接矩阵，$3\le N \le 3000$,问有多少对$(i,j,k)$满足两两存在边

## 思路

这题解法让我大受震撼。

考虑暴力枚举三个点，时间复杂度$O(n^3)$,大概$9 \times 10^9$的规模，显然过不了。

使用`bitset`优化，时间复杂度为$O(\frac{n^3}{w}),w = 64$,规模一下变成了 $10^8$。

时限$3s$跑了$1068ms$ 

 ![image-20220703162432579](ABC258/image-20220703162432579.png)
## 代码

``` cpp
#include<bits/stdc++.h>
#define all(x) begin(x), end(x)
using namespace std;
using ll = long long;
using PII = pair<int,int>;
constexpr int mod = 998244353;
constexpr int INF = 0x3f3f3f3f;
constexpr int N = 3333;
int n;
bitset<N>a[N];
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    cin>>n;
    for(int i=1;i<=n;++i){
        string s;
        cin>>s;
        for(int j=i;j<n;++j){
            if(s[j]=='1')a[i].set(j+1);
        }
    }
    ll ans = 0;
    for(int i=1;i<=n;++i){
        for(int j=i+1;j<=n;++j){
            if(a[i][j])ans+=(a[i]&a[j]).count();
        }
    }
    cout<<ans<<'\n';
    return 0;
}
```

<!-- Q.E.D. -->

